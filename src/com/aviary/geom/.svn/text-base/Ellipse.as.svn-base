///////////////////////////////////////////////////////////
//  Ellipse.as
//  Macromedia ActionScript Implementation of the Class Ellipse
//  Generated by Enterprise Architect
//  Created on:      01-Apr-2008 8:09:22 AM
//  Original author: alessandro crugnola
///////////////////////////////////////////////////////////

package com.aviary.geom
{
	import __AS3__.vec.Vector;
	
	import com.aviary.events.HandleEvent;
	import com.aviary.geom.controls.Handle;
	import com.aviary.geom.controls.HandleType;
	import com.aviary.geom.controls.IHandle;
	import com.aviary.geom.path.IPath;
	import com.aviary.geom.path.Path;
	import com.aviary.raven.io.LoaderUtils;
	import com.aviary.sdk.storage.eggfile.IEGGNode;
	import com.aviary.sdk.storage.eggfile.attributes.AttributeTypes;
	import com.aviary.sdk.storage.eggfile.attributes.BinaryAttribute;
	import com.aviary.sdk.storage.eggfile.attributes.LazyAttribute;
	
	import flash.display.Graphics;
	import flash.geom.Point;
	import flash.geom.Rectangle;
	import flash.utils.ByteArray;

	/**
	 * @author alessandro crugnola
	 * @version 1.0
	 * @created 01-Apr-2008 8:09:22 AM
	 */
	public class Ellipse extends Shape
	{
	    private var center: Handle;
	    private var h_radius: Handle;
	    private var v_radius: Handle;

	    /**
	     * 
	     * @param cx
	     * @param cy
	     * @param width
	     * @param heigh    heigh
	     */
	    public function Ellipse( cx: Number = 0, cy: Number = 0, width: Number = 0, heigh: Number = 0 )
	    {
			super();
        	center = new Handle( 'center', cx, cy );
        	h_radius = new Handle( 'hradius', cx + width, cy, HandleType.CONTROL_FORM );
        	v_radius = new Handle( 'vradius', cx, cy + heigh, HandleType.CONTROL_FORM );
        	
        	_boundingBox = new Rectangle( cx - width, cy - heigh, width * 2, heigh * 2 );
        	_handles = Vector.<IHandle>( [ center, h_radius, v_radius ] );
        	
        	_handles_dict[ center.name ]   = 0;
        	_handles_dict[ h_radius.name ] = 1;
        	_handles_dict[ v_radius.name ] = 2;
        	
        	center.addEventListener( HandleEvent.HANDLE_CHANGE,   onHandleChange );
        	h_radius.addEventListener( HandleEvent.HANDLE_CHANGE, onHandleChange );	
        	v_radius.addEventListener( HandleEvent.HANDLE_CHANGE, onHandleChange );
        	
			eggNode.setAttribute( new LazyAttribute( "shape:center", AttributeTypes.BINARY_TYPE, encodePt0 ) );
			eggNode.setAttribute( new LazyAttribute( "shape:hradius", AttributeTypes.BINARY_TYPE, encodePt1 ) );
			eggNode.setAttribute( new LazyAttribute( "shape:vradius", AttributeTypes.BINARY_TYPE, encodePt2 ) );
	    }

	    private function onHandleChange(event:HandleEvent): void
	    {
			if( ( event.target as Handle ).name == 'center' )
			{
				var diff_point: Point = center.point.subtract( event.old_point );
				var new_radius: Point = h_radius.point.add( diff_point );
				h_radius.setPoint( new_radius, false );

				diff_point = center.point.subtract( event.old_point );
				new_radius = v_radius.point.add( diff_point );
				v_radius.setPoint( new_radius, false );
				
			} else if( ( event.target as Handle ).name == 'vradius' )
			{
				v_radius.point.x = center.point.x;
			} else if( ( event.target as Handle ).name == 'hradius' )
			{
				h_radius.point.y = center.point.y;
			}
			_boundingBox = null;	    	
	    }

	    public override function get boundingBox(): Rectangle
	    {
			if( !_boundingBox )
			{
				var width: Number  = Point.distance( h_radius.point, center.point );
				var height: Number = Point.distance( v_radius.point, center.point );
				_boundingBox = new Rectangle( center.point.x - width, center.point.y - height, width * 2, height * 2 );
			}
			return _boundingBox;	    	
	    }
		
		
	    public override function render( g: Graphics ): void
	    {
			g.drawEllipse( this.center.point.x - Point.distance( this.h_radius.point, this.center.point ), 
							this.center.point.y - Point.distance( this.v_radius.point, this.center.point ), 
							Point.distance( this.h_radius.point, this.center.point )*2,
							Point.distance( this.v_radius.point, this.center.point )*2 );	    	
	    }
		
	    public override function generatePath(): IPath
	    {
			var rh: Number = Point.distance( h_radius.point, center.point );
			var rv: Number = Point.distance( v_radius.point, center.point );
			var kh: Number = CURVE_CONVERSION * rh;
			var kv: Number = CURVE_CONVERSION * rv;
			var path: IPath = new Path( );
			//path.moveTo( center.point.x + rh, center.point.y );
			path.curve3To( center.point.x + rh, center.point.y - kv, center.point.x + kh, center.point.y - rv, center.point.x, center.point.y - rv );
			path.curve3To( center.point.x - kh, center.point.y - rv, center.point.x - rh, center.point.y - kv, center.point.x - rh, center.point.y );
			path.curve3To( center.point.x - rh, center.point.y + kv, center.point.x - kh, center.point.y + rv, center.point.x, center.point.y + rv );
			path.curve3To( center.point.x + kh, center.point.y + rv, center.point.x + rh, center.point.y + kv, center.point.x + rh, center.point.y );
			//path.closed = true;
			path.close( );
			( path as Path ).colorRect = this.colorRect;
			return path;	    	
	    }
	    
		protected function encodePt0( ): ByteArray
		{
			return LoaderUtils.encodePoint( center.point );
		}
		
		protected function encodePt1( ): ByteArray
		{
			return LoaderUtils.encodePoint( h_radius.point );
		}
		
		protected function encodePt2( ): ByteArray
		{
			return LoaderUtils.encodePoint( v_radius.point );
		}
		
		override public function decode( node: IEGGNode ): void
		{
			( node.attributes['shape:center'].data  as ByteArray ).position = 0;
			( node.attributes['shape:hradius'].data as ByteArray ).position = 0;
			( node.attributes['shape:vradius'].data as ByteArray ).position = 0;
			
			var pt0: Point = LoaderUtils.decodePoint( node.attributes['shape:center'].data ); 
			var pt1: Point = LoaderUtils.decodePoint( node.attributes['shape:hradius'].data ); 
			var pt2: Point = LoaderUtils.decodePoint( node.attributes['shape:vradius'].data );
			
			var h_width: Number = Point.distance( pt1, pt0 );
			var v_width: Number = Point.distance( pt2, pt0 );
			
			this.center.setPoint( pt0, false );
			this.h_radius.setPoint( new Point( pt0.x + h_width, pt0.y ), false );
			this.v_radius.setPoint( new Point( pt0.x, pt0.y + v_width ), false );
			invalidate( );
			
		}
		
		override public function encode(): IEGGNode
		{
			var node: IEGGNode = createEggNode( );
			node.setAttribute( new BinaryAttribute( "shape:center",  encodePt0() ) );
			node.setAttribute( new BinaryAttribute( "shape:hradius", encodePt1() ) );
			node.setAttribute( new BinaryAttribute( "shape:vradius", encodePt2() ) );
			return node;
		}

	}//end Ellipse

}