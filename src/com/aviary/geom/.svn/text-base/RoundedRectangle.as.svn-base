///////////////////////////////////////////////////////////
//  RoundedRectangle.as
//  Macromedia ActionScript Implementation of the Class RoundedRectangle
//  Generated by Enterprise Architect
//  Created on:      01-Apr-2008 8:09:29 AM
//  Original author: alessandro crugnola
///////////////////////////////////////////////////////////

package com.aviary.geom
{
	import __AS3__.vec.Vector;
	
	import com.aviary.events.HandleEvent;
	import com.aviary.geom.controls.Handle;
	import com.aviary.geom.controls.HandleType;
	import com.aviary.geom.controls.IHandle;
	import com.aviary.geom.path.IPath;
	import com.aviary.geom.path.Path;
	import com.aviary.raven.io.LoaderUtils;
	import com.aviary.sdk.storage.eggfile.IEGGNode;
	import com.aviary.sdk.storage.eggfile.attributes.AttributeTypes;
	import com.aviary.sdk.storage.eggfile.attributes.BinaryAttribute;
	import com.aviary.sdk.storage.eggfile.attributes.LazyAttribute;
	
	import flash.display.Graphics;
	import flash.display.GraphicsPathCommand;
	import flash.geom.Point;
	import flash.geom.Rectangle;
	import flash.utils.ByteArray;

	/**
	 * @author alessandro crugnola
	 * @version 1.0
	 * @created 01-Apr-2008 8:09:29 AM
	 */
	public class RoundedRectangle extends Shape
	{
	    private var pt1: Handle;
	    private var pt2: Handle;
	    private var pt3: Handle;
	    private var pt4: Handle;

		public function RoundedRectangle( x: Number = 0, y: Number = 0, width: Number = 0, height: Number = 0, cornerx: Number = 0, cornery: Number = 0 )
		{
			super();
			pt1 = new Handle( "pt1", x, y );
			pt2 = new Handle( "pt2", x + width, y + height );
			pt3 = new Handle( "cx", x + width - cornerx, y, HandleType.CONTROL_FORM );
			pt4 = new Handle( "cy", x + width, y + cornery, HandleType.CONTROL_FORM );
			
			pt1.addEventListener( HandleEvent.HANDLE_CHANGE, onHandleChange );
			pt2.addEventListener( HandleEvent.HANDLE_CHANGE, onHandleChange );
			pt3.addEventListener( HandleEvent.HANDLE_CHANGE, onHandleChange );
			pt4.addEventListener( HandleEvent.HANDLE_CHANGE, onHandleChange );
			
			_handles = Vector.<IHandle>( [ pt1, pt2, pt3, pt4 ] );
			
			_handles_dict[ pt1.name ] = 0;
			_handles_dict[ pt2.name ] = 1;
			_handles_dict[ pt3.name ] = 2;
			_handles_dict[ pt4.name ] = 3;
			
			eggNode.setAttribute( new LazyAttribute( "shape:pt1", AttributeTypes.BINARY_TYPE, encodePt0 ) );
			eggNode.setAttribute( new LazyAttribute( "shape:pt2", AttributeTypes.BINARY_TYPE, encodePt1 ) );
			eggNode.setAttribute( new LazyAttribute( "shape:cx",  AttributeTypes.BINARY_TYPE, encodePt2 ) );			
			eggNode.setAttribute( new LazyAttribute( "shape:cy",  AttributeTypes.BINARY_TYPE, encodePt3 ) );
			
			_commands = new Vector.<int>( 9, true );
			_commands[0] = GraphicsPathCommand.MOVE_TO;
			_commands[1] = GraphicsPathCommand.LINE_TO;
			_commands[2] = GraphicsPathCommand.CURVE_TO;
			_commands[3] = GraphicsPathCommand.LINE_TO;
			_commands[4] = GraphicsPathCommand.CURVE_TO;
			_commands[5] = GraphicsPathCommand.LINE_TO;
			_commands[6] = GraphicsPathCommand.CURVE_TO;
			_commands[7] = GraphicsPathCommand.LINE_TO;
			_commands[8] = GraphicsPathCommand.CURVE_TO;
			
			_data = new Vector.<Number>( 26, true );
			updatePathData( );
		}
		
		override public function get allowMultipleHandleSelection( ): Boolean
		{
			return true;
		}
		
		private function onHandleChange( event: HandleEvent ): void
		{
			var handle: Handle = event.target as Handle;
			var diffx: Number = handle.point.x - event.old_point.x;
			var diffy: Number = handle.point.y - event.old_point.y;
			var targetx: Number;
			var targety: Number;
			if( handle.name == "pt2" )
			{
				pt2.setPoint( new Point( Math.max( pt1.point.x, handle.point.x ), Math.max( pt1.point.y, handle.point.y ) ), false );
								
				targety = Math.max( pt1.point.y, Math.min( pt4.point.y, pt1.point.y + ( pt2.point.y - pt1.point.y )/2 ) );
				targetx = Math.max( pt1.point.x + ( pt2.point.x - pt1.point.x )/2, Math.min( pt3.point.x + diffx, pt2.point.x ) );
				
				pt3.setPoint( new Point( targetx, pt1.point.y ), false );
				pt4.setPoint( new Point( pt2.point.x, targety ), false );
			} else if( handle.name == "pt1" )
			{
				pt1.setPoint( new Point( Math.min( pt2.point.x, handle.point.x ), Math.min( pt2.point.y, handle.point.y ) ), false );
				
				targety = Math.max( pt1.point.y, Math.min( pt4.point.y + diffy, pt1.point.y + ( pt2.point.y - pt1.point.y )/2 ) );
				targetx = Math.max( pt1.point.x + ( pt2.point.x - pt1.point.x )/2, Math.min( pt3.point.x, pt2.point.x ) );
								
				pt3.setPoint( new Point( targetx, pt1.point.y ), false );
				pt4.setPoint( new Point( pt2.point.x, targety ), false );
			} else if( handle.name == "cx" )
			{
				targetx = Math.max( pt1.point.x + ( pt2.point.x - pt1.point.x )/2, Math.min( pt3.point.x, pt2.point.x ) );
				pt3.setPoint( new Point( targetx, pt1.point.y ), false );
			} else if( handle.name == "cy" )
			{
				targety = Math.max( pt1.point.y, Math.min( pt4.point.y, pt1.point.y + ( pt2.point.y - pt1.point.y )/2 ) );
				pt4.setPoint( new Point( pt2.point.x, targety ), false );
			}
			
			_boundingBox = null;
			updatePathData( );
		}
		
		protected function updatePathData( ): void
		{
			var cornerx: Number = pt2.point.x - pt3.point.x;
			var cornery: Number = pt4.point.y - pt1.point.y;

			_data[0] = pt1.point.x + cornerx;
			_data[1] = pt1.point.y;
			_data[2] = pt2.point.x - cornerx;
			_data[3] = pt1.point.y;
			_data[4] = pt2.point.x;
			_data[5] = pt1.point.y;
			_data[6] = pt2.point.x;
			_data[7] = pt1.point.y + cornery;
			_data[8] = pt2.point.x;
			_data[9] = pt2.point.y - cornery;
			_data[10] = pt2.point.x;
			_data[11] = pt2.point.y;
			_data[12] = pt2.point.x - cornerx;
			_data[13] = pt2.point.y;
			_data[14] = pt1.point.x + cornerx;
			_data[15] = pt2.point.y;
			_data[16] = pt1.point.x;
			_data[17] = pt2.point.y;
			_data[18] = pt1.point.x;
			_data[19] = pt2.point.y - cornery;
			_data[20] = pt1.point.x;
			_data[21] = pt1.point.y + cornery;
			_data[22] = pt1.point.x;
			_data[23] = pt1.point.y;
			_data[24] = pt1.point.x + cornerx;
			_data[25] = pt1.point.y;
		}
		
		override public function render( g: Graphics ): void
		{
			g.drawPath( _commands, _data );
		}
		
		override public function generatePath( ): IPath
		{
			var path: IPath = new Path( );

			var cornerx: Number = Math.round( pt2.point.x - pt3.point.x );
			var cornery: Number = Math.round( pt4.point.y - pt1.point.y );
			
			if( cornerx == 0 || cornery == 0 )
			{
				cornerx = 0;
				cornery = 0;
			}
			
			path.lineTo( pt2.point.x - cornerx, pt1.point.y );
			
			if( cornery != 0 && cornerx != 0 )
				path.curve3To( pt2.point.x - cornerx + ( cornerx * CURVE_CONVERSION ), pt1.point.y, pt2.point.x, ( pt1.point.y + cornery ) - ( cornery * CURVE_CONVERSION ), pt2.point.x, pt1.point.y + cornery );
			path.lineTo( pt2.point.x, pt2.point.y - cornery );
			
			if( cornerx != 0 && cornery != 0 )
				path.curve3To( pt2.point.x, pt2.point.y - cornery + ( cornery * CURVE_CONVERSION ), pt2.point.x - cornerx + ( cornerx * CURVE_CONVERSION ), pt2.point.y, pt2.point.x - cornerx, pt2.point.y );
			path.lineTo( pt1.point.x + cornerx, pt2.point.y );
			
			if( cornery != 0 && cornerx != 0 )
				path.curve3To( pt1.point.x + cornerx - ( cornerx * CURVE_CONVERSION ), pt2.point.y, pt1.point.x, pt2.point.y - cornery + ( cornery * CURVE_CONVERSION ), pt1.point.x, pt2.point.y - cornery );
			path.lineTo( pt1.point.x, pt1.point.y + cornery );
			
			if( cornerx != 0 && cornery != 0 )
				path.curve3To( pt1.point.x, pt1.point.y + cornery - ( cornery * CURVE_CONVERSION ), pt1.point.x + cornerx - ( cornerx * CURVE_CONVERSION ), pt1.point.y, pt1.point.x + cornerx, pt1.point.y );
			//path.closed = true;
			path.close( );
			
			return path;
		}		
		
		override public function get boundingBox( ): Rectangle
		{
			if( !_boundingBox )
			{
				var minx: Number = Math.min( pt1.point.x, pt2.point.x );
				var miny: Number = Math.min( pt1.point.y, pt2.point.y );
				var maxx: Number = Math.max( pt1.point.x, pt2.point.x );
				var maxy: Number = Math.max( pt1.point.y, pt2.point.y );
				_boundingBox = new Rectangle( minx, miny, maxx - minx, maxy - miny );
			}
			
			return _boundingBox;
		}
		
		protected function encodePt0( ): ByteArray
		{
			return LoaderUtils.encodePoint( pt1.point );
		}
		
		protected function encodePt1( ): ByteArray
		{
			return LoaderUtils.encodePoint( pt2.point );
		}
		
		protected function encodePt2( ): ByteArray
		{
			return LoaderUtils.encodePoint( pt3.point );
		}
		
		protected function encodePt3( ): ByteArray
		{
			return LoaderUtils.encodePoint( pt4.point );
		}
		
		override public function decode( node: IEGGNode ): void
		{
			( node.attributes['shape:pt1'].data as ByteArray ).position = 0;
			( node.attributes['shape:pt2'].data as ByteArray ).position = 0;
			( node.attributes['shape:cx'].data as ByteArray ).position = 0;
			( node.attributes['shape:cy'].data as ByteArray ).position = 0;
			
			var _pt1: Point = LoaderUtils.decodePoint( node.attributes['shape:pt1'].data ); 
			var _pt2: Point = LoaderUtils.decodePoint( node.attributes['shape:pt2'].data ); 
			var _cx: Point  = LoaderUtils.decodePoint( node.attributes['shape:cx'].data );
			var _cy: Point  = LoaderUtils.decodePoint( node.attributes['shape:cy'].data );
			
			this.pt1.setPoint( _pt1,false, false );
			this.pt2.setPoint( _pt2,false, false );
			this.pt3.setPoint( _cx, false, false );
			this.pt4.setPoint( _cy, false, false );
			invalidate( );
			updatePathData( );
		}
		
		override public function encode():IEGGNode
		{
			var node: IEGGNode = createEggNode( );
			node.setAttribute( new BinaryAttribute( "shape:pt1", encodePt0() ) );
			node.setAttribute( new BinaryAttribute( "shape:pt2", encodePt1() ) );
			node.setAttribute( new BinaryAttribute( "shape:cx",  encodePt2() ) );
			node.setAttribute( new BinaryAttribute( "shape:cy",  encodePt3() ) );
			return node;
		}
		
		override public function toString(): String
		{
			return "rectangle(" + pt1.point.x + "," + pt1.point.y + "," + pt2.point.x + "," + pt2.point.y + 
				"," + pt3.point.x + "," + pt3.point.y + "," + pt4.point.x + "," + pt4.point.y + ")";
		}

	}//end RoundedRectangle

}