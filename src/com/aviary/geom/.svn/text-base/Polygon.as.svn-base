///////////////////////////////////////////////////////////
//  Polygon.as
//  Macromedia ActionScript Implementation of the Class Polygon
//  Generated by Enterprise Architect
//  Created on:      01-Apr-2008 8:09:27 AM
//  Original author: alessandro crugnola
///////////////////////////////////////////////////////////

package com.aviary.geom
{
	import __AS3__.vec.Vector;
	
	import com.aviary.events.HandleEvent;
	import com.aviary.geom.controls.Handle;
	import com.aviary.geom.controls.HandleType;
	import com.aviary.geom.controls.IHandle;
	import com.aviary.geom.path.Curve3Segment;
	import com.aviary.geom.path.IPath;
	import com.aviary.geom.path.Path;
	import com.aviary.geom.utils.Point2D;
	import com.aviary.graphics.DrawingUtils;
	import com.aviary.raven.io.LoaderUtils;
	import com.aviary.sdk.storage.eggfile.IEGGNode;
	import com.aviary.sdk.storage.eggfile.attributes.AttributeTypes;
	import com.aviary.sdk.storage.eggfile.attributes.BinaryAttribute;
	import com.aviary.sdk.storage.eggfile.attributes.IntAttribute;
	import com.aviary.sdk.storage.eggfile.attributes.LazyAttribute;
	
	import flash.display.Graphics;
	import flash.geom.Point;
	import flash.geom.Rectangle;
	import flash.utils.ByteArray;

	/**
	 * @author alessandro crugnola
	 * @version 1.0
	 * @created 01-Apr-2008 8:09:27 AM
	 */
	public class Polygon extends Shape
	{
	    private var center: Handle;
	    private var radius: Handle;
	    private var corner: Handle;
	    private var _angle: Number;
	    private var _sides: uint;
	    private var _dist: Number;

	    /**
	     * 
	     * @param x
	     * @param y
	     * @param r
	     * @param s
	     * @param angle    angle
	     */
	    public function Polygon( x: Number = 0, y: Number = 0, r: Number = 0, s: uint = 0, angle: Number = 0 )
	    {
			super();
			_dist   = 1;
			_sides  = Math.max( s, 3 );
			center = new Handle( 'center', x, y );
			
			var _pt2: Point = new Point( x + ( Math.cos( angle ) * r ), y - ( Math.sin( angle ) * r ) );			
			
			radius = new Handle( 'radius', _pt2.x, _pt2.y, HandleType.CONTROL_FORM );
			
			var pt0: Point = getPointAt( _sides - 1 );
			var pt1: Point = getPointAt( _sides );
			var mid: Point = Point2D.getLerp( pt0, pt1, .5 );
			corner = new Handle( 'corner', mid.x, mid.y, HandleType.CONTROL_FORM );				
			
			_handles = Vector.<IHandle>( [ center, radius, corner ] );
			
			_handles_dict[ center.name ] = 0;
			_handles_dict[ radius.name ] = 1;
			_handles_dict[ corner.name ] = 2;

        	center.addEventListener( HandleEvent.HANDLE_CHANGE, onHandleChange );
        	radius.addEventListener( HandleEvent.HANDLE_CHANGE, onHandleChange );
        	corner.addEventListener( HandleEvent.HANDLE_CHANGE, onHandleChange );	
        	
        	eggNode.setAttribute( new LazyAttribute( "shape:center", AttributeTypes.BINARY_TYPE, encodeCenter ) );    	
        	eggNode.setAttribute( new LazyAttribute( "shape:radius", AttributeTypes.BINARY_TYPE, encodeRadius ) );    	
        	eggNode.setAttribute( new LazyAttribute( "shape:corner", AttributeTypes.BINARY_TYPE, encodeCorner ) );
        	eggNode.setAttribute( new IntAttribute( "shape:sides", _sides ) );
	    }

	    /**
	     * 
	     * @param value    value
	     */
	    public function set sides(value:uint): void
	    {
			_sides = Math.max( 3, value );
			eggNode.setAttribute( new IntAttribute( "shape:sides", _sides ) );
			_boundingBox = null;	    	
	    }

	    public function get sides(): uint
	    {
			return _sides;
	    }

	    /**
	     * 
	     * @param event    event
	     */
	    private function onHandleChange(event:HandleEvent): void
	    {
			var handle: Handle = event.target as Handle;
			var diff_point: Point = handle.point.subtract( event.old_point );
			var pt0: Point;
			var pt1: Point;
			var mid: Point;
			if( handle.name == 'center' )
			{
				radius.setPoint( radius.point.add( diff_point ), false );
				corner.setPoint( corner.point.add( diff_point ), false );
			} else if( handle.name == 'radius' )
			{
				//updateCornerPoint( );
			} else if( handle.name == 'corner' )
			{
				updateRoundedValue( );
			}
			updateCornerPoint( );
			_boundingBox = null;
	    }

	    private function updateCornerPoint( ): void
	    {
			var pt0: Point = getPointAt( _sides - 1 );
			var pt1: Point = getPointAt( _sides );				
			var mid: Point = Point2D.getLerp( pt0, pt1, .5 );
			var dest: Point = Point2D.getLerp( center.point, mid, _dist );
			corner.setPoint( new Point( dest.x, dest.y ), false );
	    }

	    private function updateRoundedValue(): void
	    {
			var pt0: Point = getPointAt( _sides - 1 );
			var pt1: Point = getPointAt( _sides );				
			var maxDist: Number = Point.distance( Point2D.getLerp( pt0, pt1, .5 ), center.point );
			var cornerDist: Number = Point.distance( corner.point, center.point );
			var mid: Point = Point2D.getLerp( pt0, pt1, .5 );
			_dist = cornerDist / maxDist;
	    }

	    /**
	     * 
	     * @param walker    walker
	     */
	    public override function render( g: Graphics ): void
	    {
			var outer_radius:  Number = Point.distance( radius.point, center.point );
			DrawingUtils.drawPolygon( g, center.point.x, center.point.y, sides, outer_radius, angle - ( Math.PI / 2 ), _dist );	    	
	    }

	    public override function generatePath(): IPath
	    {
			var path: IPath = new Path( );
			var outerRadius: Number = Point.distance( radius.point, center.point );
			var start: Number;
			var step: Number;
			var n: int;
			var dx: int;
			var dy: int;
			
			step = ( Math.PI * 2 ) / _sides;
			start = - angle;
			var current:Point = getPointAt( 0 );
			path.start( current.x, current.y );
			
			for ( n = 1; n <= _sides; n++ )
			{
				var pt: Point = getPointAt( n );
				if( _dist == 1 )
				{
					path.lineTo( pt.x, pt.y );
				} else {
					var mid: Point = Point2D.getLerp( pt, current, 0.5 );
					var dest: Point = Point2D.getLerp( center.point, mid, _dist );
					
					var P01: Point  = Point2D.getLerp( current, dest, BEZIER2_CONVERSION );
					var P02: Point  = Point2D.getLerp( pt, dest, BEZIER2_CONVERSION );
					
					// ezekiel.vancouver.wsu.edu/~cs442/lectures/bezier/bezier.pdf
					path.curve3To( P01.x, P01.y, P02.x, P02.y, pt.x, pt.y );
				}
				current = pt.clone( );
			}
			//path.closed = true;
			path.close( );
			( path as Path ).colorRect = this.colorRect;
			return path;	    	
	    }

	    /**
	     * 
	     * @param nside    nside
	     */
	    private function getPointAt(nside:uint): Point
	    {
			var outerRadius: Number = Point.distance( radius.point, center.point );
			var step: Number = ( Math.PI * 2 ) / _sides;
			var start: Number = angle - ( Math.PI / 2 );
			var dx: Number = center.point.x + Math.cos( start + ( step * nside ) ) * outerRadius;
			var dy: Number = center.point.y - Math.sin( start + ( step * nside ) ) * outerRadius;
			return new Point( dx, dy );	    	
	    }

	    private function get angle(): Number
	    {
			return Point2D.rad( radius.point, center.point );
	    }

	    public override function get boundingBox(): Rectangle
	    {
			if( !_boundingBox )
			{
				var point: Point = getPointAt( 0 );
				var minx: Number = point.x;				
				var miny: Number = point.y;				
				var maxx: Number = point.x;				
				var maxy: Number = point.y;
				
				var outerRadius: Number = Point.distance( radius.point, center.point );
				
				var start: Number;
				var step: Number;
				var n: int;
				var dx: int;
				var dy: int;
				step = ( Math.PI * 2 ) / _sides;
				start = - angle;
				
				if( _dist <= 1 )
				{
					for ( n = 1; n <= _sides; n++ )
					{
						point = getPointAt( n );
						minx = Math.min( minx, point.x );
						miny = Math.min( miny, point.y );
						maxx = Math.max( maxx, point.x );
						maxy = Math.max( maxy, point.y );
					}
				} else 
				{
					var path: IPath = new Path( );
					path.start( point.x, point.y );
					
					for ( n = 1; n <= _sides; n++ )
					{
						var pt: Point = getPointAt( n );
						var mid: Point  = Point2D.getLerp( pt, point, 0.5 );
						var dest: Point = Point2D.getLerp( center.point, mid, _dist );
						var P01: Point  = Point2D.getLerp( point, dest, BEZIER2_CONVERSION );
						var P02: Point  = Point2D.getLerp( pt, dest, BEZIER2_CONVERSION );
						var segment: Curve3Segment = path.curve3To( P01.x, P01.y, P02.x, P02.y, pt.x, pt.y ) as Curve3Segment;
						var middle: Point = segment.getLerp( 0.5 );
						
						minx = Math.min( minx, pt.x );
						miny = Math.min( miny, pt.y );
						maxx = Math.max( maxx, pt.x );
						maxy = Math.max( maxy, pt.y );
						
						minx = Math.min( minx, middle.x );
						miny = Math.min( miny, middle.y );
						maxx = Math.max( maxx, middle.x );
						maxy = Math.max( maxy, middle.y );
						
						point = pt.clone( );
					}
				}
				
				_boundingBox = new Rectangle( minx, miny, maxx - minx, maxy - miny );
			}
			return _boundingBox;
	    }
	    
		protected function encodeCenter( ): ByteArray
		{
			return LoaderUtils.encodePoint( center.point );
		}
		
		protected function encodeRadius( ): ByteArray
		{
			return LoaderUtils.encodePoint( radius.point );
		}

		protected function encodeCorner( ): ByteArray
		{
			return LoaderUtils.encodePoint( corner.point );
		}
		
		override public function decode(node:IEGGNode):void
		{
			( node.attributes['shape:center'].data as ByteArray ).position = 0;
			( node.attributes['shape:radius'].data as ByteArray ).position = 0;
			( node.attributes['shape:corner'].data as ByteArray ).position = 0;
			
			var pt0: Point = LoaderUtils.decodePoint( node.attributes['shape:center'].data ); 
			var pt1: Point = LoaderUtils.decodePoint( node.attributes['shape:radius'].data ); 
			var pt2: Point = LoaderUtils.decodePoint( node.attributes['shape:corner'].data );
			var sides: uint = node.attributes['shape:sides'].data as int;

			this.center.setPoint( pt0, false, false );
			this.radius.setPoint( pt1, false, false );
			this.corner.setPoint( pt2, false, false );
			this.sides = sides;
			
			updateRoundedValue( );
			updateCornerPoint( );		
			
			invalidate( );
		}
		
		override public function encode():IEGGNode
		{
			var node: IEGGNode = createEggNode( );
			node.setAttribute( new BinaryAttribute( "shape:center", encodeCenter() ) );    	
        	node.setAttribute( new BinaryAttribute( "shape:radius", encodeRadius() ) );    	
        	node.setAttribute( new BinaryAttribute( "shape:corner", encodeCorner() ) );
        	node.setAttribute( new IntAttribute( "shape:sides", _sides ) );
        	return node;
		}
		
		override public function toString():String
		{
			return "polygon(" + center.point.x + "," + center.point.y + "," + 
				radius.point.x + "," + radius.point.y + "," + corner.point.x + "," + corner.point.y + ")";
		}		

	}//end Polygon

}