///////////////////////////////////////////////////////////
//  Star.as
//  Macromedia ActionScript Implementation of the Class Star
//  Generated by Enterprise Architect
//  Created on:      01-Apr-2008 8:09:30 AM
//  Original author: alessandro crugnola
///////////////////////////////////////////////////////////

package com.aviary.geom
{
	import __AS3__.vec.Vector;
	
	import com.aviary.events.HandleEvent;
	import com.aviary.geom.controls.Handle;
	import com.aviary.geom.controls.HandleType;
	import com.aviary.geom.controls.IHandle;
	import com.aviary.geom.path.IPath;
	import com.aviary.geom.path.Path;
	import com.aviary.geom.utils.Point2D;
	import com.aviary.raven.io.LoaderUtils;
	import com.aviary.sdk.storage.eggfile.IEGGNode;
	import com.aviary.sdk.storage.eggfile.attributes.AttributeTypes;
	import com.aviary.sdk.storage.eggfile.attributes.BinaryAttribute;
	import com.aviary.sdk.storage.eggfile.attributes.IntAttribute;
	import com.aviary.sdk.storage.eggfile.attributes.LazyAttribute;
	
	import flash.display.Graphics;
	import flash.display.GraphicsPathCommand;
	import flash.geom.Point;
	import flash.geom.Rectangle;
	import flash.utils.ByteArray;

	/**
	 * @author alessandro crugnola
	 * @version 1.0
	 * @created 01-Apr-2008 8:09:30 AM
	 */
	public class Star extends Shape
	{
		private var dirty: Boolean;
	    private var pt0: Handle;
	    private var pt1: Handle;
	    private var pt2: Handle;
	    private var _corners: uint = 5;

	    /**
	     * 
	     * @param x
	     * @param y
	     * @param r
	     * @param c
	     * @param angle    angle
	     */
		public function Star( x: Number = 0, y: Number = 0, r: Number = 0, c: uint = 0, angle: Number = 0 )
		{
			super( );
			
			dirty = true;
			
			// center
			pt0 = new Handle( 'pt0', x, y );
			
			var step: Number = ( Math.PI * 2 ) / c;
			var _pt1: Point = new Point( );
			_pt1.x = x + Math.cos( angle + ( step * ( c ) ) - ( step / 2 ) ) * ( r / 2 );
			_pt1.y = y - Math.sin( angle + ( step * ( c ) ) - ( step / 2 ) ) * ( r / 2 );
			
			var _pt2: Point = new Point( );
			_pt2.x = x + ( Math.cos( angle ) * r );
			_pt2.y = y - ( Math.sin( angle ) * r );
			
			pt1 = new Handle( 'pt1', _pt1.x, _pt1.y, HandleType.CONTROL_FORM );
			pt2 = new Handle( 'pt2', _pt2.x, _pt2.y, HandleType.CONTROL_FORM );
			
			_corners = Math.max( 3, c );
			
			pt0.addEventListener( HandleEvent.HANDLE_CHANGE, onHandleChange );
			pt1.addEventListener( HandleEvent.HANDLE_CHANGE, onHandleChange );
			pt2.addEventListener( HandleEvent.HANDLE_CHANGE, onHandleChange );
			_handles = Vector.<IHandle>( [ pt0, pt1, pt2 ] );
			
			_handles_dict[ pt0.name ] = 0;
			_handles_dict[ pt1.name ] = 1;
			_handles_dict[ pt2.name ] = 2;
			
			eggNode.setAttribute( new LazyAttribute( "shape:pt0", AttributeTypes.BINARY_TYPE, encodePt0 ) );
			eggNode.setAttribute( new LazyAttribute( "shape:pt1", AttributeTypes.BINARY_TYPE, encodePt1 ) );
			eggNode.setAttribute( new LazyAttribute( "shape:pt2", AttributeTypes.BINARY_TYPE, encodePt2 ) );
			eggNode.setAttribute( new IntAttribute( "shape:corner", _corners ) );
			
			updateData( );
		}
		
		public function get corners( ): uint
		{
			return _corners;
		}
		
		public function set corners( value: uint ): void
		{
			_corners = Math.max( 3, value );
			eggNode.setAttribute( new IntAttribute( "shape:corner", _corners ) );
			_boundingBox = null;
			
			dirty = true;
			updateData( );
		}
		
		private function onHandleChange( event: HandleEvent ): void
		{
			var handle: Handle = event.target as Handle;
			var diff_point: Point;
			var distance: Number;
			var np: Point;
			var inner_radius: Number;
			var r: Number;
			var step: Number;
			var x1: Number;
			var y1: Number;
			
			if( handle.name == 'pt0' )
			{
				diff_point = handle.point.subtract( event.old_point );
				pt1.setPoint( new Point( pt1.point.x + diff_point.x, pt1.point.y + diff_point.y ), false );
				pt2.setPoint( new Point( pt2.point.x + diff_point.x, pt2.point.y + diff_point.y ), false );
			} else if( handle.name == 'pt2' )
			{
				inner_radius = Point.distance( pt1.point, pt0.point );
				r = Point.distance( pt2.point, pt0.point );
				step = ( Math.PI * 2 ) / corners;
				x1 = pt0.point.x + Math.cos( ( angle - ( Math.PI/2)) + ( step * ( corners ) ) - ( step / 2 ) ) * inner_radius;
				y1 = pt0.point.y - Math.sin( ( angle - ( Math.PI/2)) + ( step * ( corners ) ) - ( step / 2 ) ) * inner_radius;
				pt1.setPoint( new Point( x1, y1 ), false );
				
			} else if( handle.name == 'pt1' )
			{
				inner_radius = Point.distance( pt1.point, pt0.point );
				r = Point.distance( pt2.point, pt0.point );
				step = ( Math.PI * 2 ) / corners;
				x1 = pt0.point.x + Math.cos( ( angle - ( Math.PI/2)) + ( step * ( corners ) ) - ( step / 2 ) ) * inner_radius;
				y1 = pt0.point.y - Math.sin( ( angle - ( Math.PI/2)) + ( step * ( corners ) ) - ( step / 2 ) ) * inner_radius;
				pt1.setPoint( new Point( x1, y1 ), false );
			}
			
			dirty = true;
			_boundingBox = null;
			updateData( );
		}
		
		public function get angle( ): Number
		{
			return Point2D.rad( pt2.point, pt0.point );
		}
		
		override public function get boundingBox( ): Rectangle
		{
			if( ! _boundingBox )
			{
				var _minx: Number;
				var _miny: Number;
				var _maxx: Number = Number.NEGATIVE_INFINITY;
				var _maxy: Number = Number.NEGATIVE_INFINITY;
				
				var dx:Number;
				var dy:Number;
				
				var inner_radius:  Number = Point.distance( pt2.point, pt0.point );
				var inner_radius2: Number = Point.distance( pt1.point, pt0.point );
				
				var angle: Number = Point2D.rad( pt2.point, pt0.point );
	
				var step:Number     = ( Math.PI * 2 ) / corners;
				var halfStep:Number = step / 2;
				var start:Number    = -angle;
	
				if( inner_radius2 < inner_radius )
				{
					_minx = Number.POSITIVE_INFINITY;
					_miny = Number.POSITIVE_INFINITY;
				} else 
				{
					_minx = pt0.point.x + ( Math.cos( start ) * inner_radius2 );
					_miny = pt0.point.y - ( Math.sin( start ) * inner_radius2 );
				}
	
				for ( var n:uint = 1; n <= corners; ++n )
				{
					if( inner_radius > inner_radius2 )
					{
						dx = pt0.point.x + Math.cos( start + ( step * n ) - halfStep ) * inner_radius;
						dy = pt0.point.y - Math.sin( start + ( step * n ) - halfStep ) * inner_radius;
						
						_minx = Math.min( _minx, dx );
						_miny = Math.min( _miny, dy );
						_maxx = Math.max( _maxx, dx );
						_maxy = Math.max( _maxy, dy );
					} else 
					{
						dx = pt0.point.x + Math.cos( start + ( step * n ) ) * inner_radius2;
						dy = pt0.point.y - Math.sin( start + ( step * n ) ) * inner_radius2;
					
						_minx = Math.min( _minx, dx );
						_miny = Math.min( _miny, dy );
						_maxx = Math.max( _maxx, dx );
						_maxy = Math.max( _maxy, dy );
					}
				}

				_boundingBox = new Rectangle( _minx, _miny, _maxx - _minx, _maxy - _miny );
			}
			return _boundingBox;
		}
		
		override public function render( g: Graphics ): void
		{
			g.drawPath( _commands, _data );
		}
		
		private function updateData( ): void
		{
			if( dirty )
			{
				_commands = new Vector.<int>( );
				_data = new Vector.<Number>( );
				
				var step: Number;
				var halfStep: Number;
				var n: uint;
				var dx: Number;
				var dy: Number;
				var x: Number = pt0.point.x;
				var y: Number = pt0.point.y;
				var _angle: Number = angle - ( Math.PI / 2 );

				var innerRadius:  Number = Point.distance( pt1.point, pt0.point );
				var outerRadius:  Number = Point.distance( pt2.point, pt0.point );

				step = ( Math.PI * 2 ) / corners;
				halfStep = step / 2;

				_commands.push( GraphicsPathCommand.MOVE_TO );
				_data.push( x + ( Math.cos( _angle ) * outerRadius ), y - ( Math.sin( _angle ) * outerRadius ) );
				for ( n = 1; n <= corners; n++ ) 
				{
					dx = x + Math.cos( _angle + ( step * n ) - halfStep ) * innerRadius;
					dy = y - Math.sin( _angle + ( step * n ) - halfStep ) * innerRadius;
					_commands.push( GraphicsPathCommand.LINE_TO );
					_data.push( dx, dy );
					dx = x + Math.cos( _angle + ( step * n ) ) * outerRadius;
					dy = y - Math.sin( _angle + ( step * n ) ) * outerRadius;
					_commands.push( GraphicsPathCommand.LINE_TO );
					_data.push( dx, dy );
				}
				dirty = false;
			}
		}
		
		override public function generatePath( ): IPath
		{
			var path: IPath = new Path( );
			
			var dx:Number;
			var dy:Number;
			
			var inner_radius:  Number = Point.distance( pt2.point, pt0.point );
			var inner_radius2: Number = Point.distance( pt1.point, pt0.point );
			var angle: Number = Point2D.rad( pt2.point, pt0.point );

			var step:Number     = ( Math.PI * 2 ) / corners;
			var halfStep:Number = step / 2;
			var start:Number    = -angle;

			for ( var n:uint = 1; n <= corners; ++n )
			{
				dx = pt0.point.x + Math.cos( start + ( step * n ) - halfStep ) * inner_radius;
				dy = pt0.point.y - Math.sin( start + ( step * n ) - halfStep ) * inner_radius;
				path.lineTo( dx, dy );
				dx = pt0.point.x + Math.cos( start + ( step * n ) ) * inner_radius2;
				dy = pt0.point.y - Math.sin( start + ( step * n ) ) * inner_radius2;
				path.lineTo( dx, dy );
			}
			
			//path.closed = true;
			path.close( );
			( path as Path ).colorRect = this.colorRect;
			return path;			
		}
		
		protected function encodePt0( ): ByteArray
		{
			return LoaderUtils.encodePoint( pt0.point );
		}
		
		protected function encodePt1( ): ByteArray
		{
			return LoaderUtils.encodePoint( pt1.point );
		}
		
		protected function encodePt2( ): ByteArray
		{
			return LoaderUtils.encodePoint( pt2.point );
		}
		
		override public function decode( node: IEGGNode ): void
		{
			( node.attributes['shape:pt0'].data as ByteArray ).position = 0;
			( node.attributes['shape:pt1'].data as ByteArray ).position = 0;
			( node.attributes['shape:pt2'].data as ByteArray ).position = 0;
			
			var corners: uint = node.attributes['shape:corner'].data as int;
			var pt0: Point = LoaderUtils.decodePoint( node.attributes['shape:pt0'].data ); 
			var pt1: Point = LoaderUtils.decodePoint( node.attributes['shape:pt1'].data ); 
			var pt2: Point = LoaderUtils.decodePoint( node.attributes['shape:pt2'].data );
			var r: Number = Point.distance( pt2, pt0 ); 
			
			this.pt0.setPoint( pt0, false, false );
			this.pt1.setPoint( pt1, false, false );
			this.pt2.setPoint( pt2, false, false );
			this.corners = corners;
			invalidate( );
			
			dirty = true;
			updateData( );
		}
		
		override public function encode():IEGGNode
		{
			var node: IEGGNode = createEggNode( );
			node.setAttribute( new BinaryAttribute( "shape:pt0", encodePt0() ) );
			node.setAttribute( new BinaryAttribute( "shape:pt1", encodePt1() ) );
			node.setAttribute( new BinaryAttribute( "shape:pt2", encodePt2() ) );
			node.setAttribute( new IntAttribute( "shape:corner", _corners ) );
			return node;
		}
		
		override public function toString():String
		{
			return "star(" + pt0.point.x + "," + pt0.point.y + "," + pt1.point.x + "," + pt1.point.y + "," + pt2.point.x + "," + pt2.point.y + "," + corners + ")";
		}
		
	}//end Star

}