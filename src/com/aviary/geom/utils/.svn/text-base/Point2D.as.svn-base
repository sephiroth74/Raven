///////////////////////////////////////////////////////////
//  Point2D.as
//  Macromedia ActionScript Implementation of the Class Point2D
//  Generated by Enterprise Architect
//  Created on:      01-Apr-2008 8:09:27 AM
//  Original author: alessandro crugnola
///////////////////////////////////////////////////////////

package com.aviary.geom.utils
{
	import flash.geom.Point;
	
	/**
	 * @author alessandro crugnola
	 * @version 1.0
	 * @created 01-Apr-2008 8:09:27 AM
	 */
	public class Point2D
	{
	    /**
	     * 
	     * @param value
	     * @param scalar    scalar
	     */
	    static public function add(value:Point, scalar:Number): Point
	    {
	    	return new Point( value.x + scalar, value.y + scalar);
	    }

	    /**
	     * 
	     * @param value
	     * @param scalar    scalar
	     */
	    static public function addScalar(value:Point, scalar:Number): Point
	    {
	    	return new Point( value.x + scalar, value.y + scalar );
	    }

	    /**
	     * 
	     * @param value
	     * @param value2    value2
	     */
	    static public function addPointEquals(value:Point, value2:Point): Point
	    {
	    	return new Point( value.x += value2.x, value.y += value2.y );
	    }

	    /**
	     * 
	     * @param value
	     * @param scalar    scalar
	     */
	    static public function subtract(value:Point, scalar:Number): Point
	    {
	    	return new Point( value.x - scalar, value.y - scalar );
	    }
	    
	    /**
	    * substract point B from point A
	    * Return a new Point
	    */
	    static public function sub( a: Point, b: Point ): Point
	    {
	    	return new Point( a.x - b.x, a.y - b.y );
	    }
	    
		public static function getLength( pt: Point ): Number
		{
			return Math.sqrt( pt.x * pt.x + pt.y * pt.y );
		}
	    
		public static function addLengthEquals( pt: Point, len: Number ): Point
		{
			var l: Number = getLength( pt );
			pt.x /= l / len;
			pt.y /= l / len;
			if( isNaN( pt.x ) ) pt.x = 0;
			if( isNaN( pt.y ) ) pt.y = 0;
			return pt;
		}	    

	    /**
	     * 
	     * @param value
	     * @param scalar    scalar
	     */
	    static public function subtractEquals(value:Point, scalar:Number): Point
	    {
	    	return new Point( value.x -= scalar, value.y -= scalar );
	    }

	    /**
	     * 
	     * @param value
	     * @param value2    value2
	     */
	    static public function subtractPointEquals(value:Point, value2:Point): Point
	    {
	    	return new Point( value.x -= value2.x, value.y -= value2.y );
	    }

	    /**
	     * 
	     * @param value
	     * @param scalar    scalar
	     */
	    static public function multiply(value:Point, scalar:Number): Point
	    {
	    	return new Point( value.x * scalar, value.y * scalar );
	    }
	    
	    static public function dot( p1: Point, p2: Point ): Number
	    {
	    	return p1.x * p2.x + p1.y * p2.y;
	    }

	    /**
	     * 
	     * @param value
	     * @param scalar    scalar
	     */
	    static public function multiplyEquals(value:Point, scalar:Number): Point
	    {
	    	return new Point( value.x *= scalar, value.y *= scalar );
	    }

	    /**
	     * 
	     * @param value
	     * @param scalar    scalar
	     */
	    static public function divide(value:Point, scalar:Number): Point
	    {
	    	return new Point( value.x / scalar, value.y / scalar );
	    }

	    /**
	     * 
	     * @param value
	     * @param scalar    scalar
	     */
	    static public function divideEquals(value:Point, scalar:Number): Point
	    {
	    	return new Point( value.x /= scalar, value.y /= scalar );
	    }

	    /**
	     * 
	     * @param first
	     * @param second    second
	     */
	    static public function lt(first:Point, second:Point): Boolean
	    {
	    	return ( first.x < second.x && first.y < second.y );
	    }

	    /**
	     * 
	     * @param pt1
	     * @param pt2    pt2
	     */
	    static public function lte(pt1:Point, pt2:Point): Boolean
	    {
	    	return ( pt1.x <= pt2.x && pt1.y <= pt2.y );
	    }

	    /**
	     * 
	     * @param pt1
	     * @param pt2    pt2
	     */
	    static public function gt(pt1:Point, pt2:Point): Boolean
	    {
	    	return ( pt1.x > pt2.x && pt1.y > pt2.y );
	    }

	    /**
	     * 
	     * @param pt1
	     * @param pt2    pt2
	     */
	    static public function gte(pt1:Point, pt2:Point): Boolean
	    {
	    	return ( pt1.x >= pt2.x && pt1.y >= pt2.y );
	    }

	    /**
	     * 
	     * @param pt1
	     * @param pt2
	     * @param t    t
	     */
	    static public function getLerp(pt1:Point, pt2:Point, t:Number): Point
	    {
	    	return new Point( pt1.x + ( pt2.x - pt1.x ) * t, pt1.y + ( pt2.y - pt1.y ) * t );
	    }

	    /**
	     * 
	     * @param pt1
	     * @param pt2    pt2
	     */
	    static public function min(pt1:Point, pt2:Point): Point
	    {
	    	return new Point( Math.min( pt1.x, pt2.x ), Math.min( pt1.y, pt2.y ) );
	    }

	    /**
	     * 
	     * @param pt1
	     * @param pt2    pt2
	     */
	    static public function max(pt1:Point, pt2:Point): Point
	    {
	    	return new Point( Math.max( pt1.x, pt2.x ), Math.max( pt1.y, pt2.y ) );
	    }

	    /**
	     * Inline swap between 2 points
	     * 
	     * @param pt1
	     * @param pt2    pt2
	     */
	    static public function swap(pt1:Point, pt2:Point): void
	    {
			var _x: Number = pt1.x;
			var _y: Number = pt2.y;
			pt1.x = pt2.x;
			pt1.y = pt2.y;
			pt2.x = _x;
			pt2.y = _y;	    	
	    }

	    /**
	     * Get the angle between 2 points
	     * 
	     * @param pt0
	     * @param pt1
	     * @param snapAngle    snap to multiplier of given angle
	     * 
	     * @return Radians between the 2 points
	     */
	    static public function rad( pt0: Point, pt1: Point, snapAngle: Number = 0 ): Number
	    {
			if( pt0.equals( pt1 ) )
				return 0;
            
            var gradiant: Number = Math.atan2( pt0.x - pt1.x, pt0.y - pt1.y );
            if( snapAngle > 0 )
            	return Math.round( gradiant / snapAngle ) * snapAngle;
            return gradiant;

	    }
	    
	    /**
	     * 
	     * @param radians	Angle in radians
	     * @param pt    
	     */
	    static public function rotate( radians: Number, pt: Point ): Point
	    {
			var result: Point = new Point( );
			var ca: Number = Math.cos ( radians );
			var sa: Number = Math.sin ( radians );
  			result.x = ( pt.x * ca ) - ( pt.y * sa );
  			result.y = ( pt.y * ca ) + ( pt.x * sa );
			return result;
	    }

	    /**
	     * 
	     * @param radians		angle in radians
	     * @param pt
	     * @param origin    origin
	     */
	    static public function rotateAroundBy( radians: Number, pt: Point, origin: Point ): Point
	    {
			var result: Point = new Point( );
			result = rotate( radians, new Point( pt.x - origin.x, pt.y - origin.y ) );
			result.x = result.x + origin.x;
			result.y = result.y + origin.y;
			return result;	    	
	    }

	    /**
	     * 
	     * @param radians		angle in radians
	     * @param pt			point to be rotated
	     * @param origin    	origin of the rotation
	     */
	    static public function rotateAroundTo( radians: Number, pt: Point, origin: Point ): Point
	    {
			var result: Point = new Point( );
			var distance: Number = Point.distance( pt, origin );
			var pt2: Point = new Point( origin.x, origin.y + distance );
			result = rotate( radians, new Point( pt2.x - origin.x, pt2.y - origin.y ) );
			result.x = result.x + origin.x;
			result.y = result.y + origin.y;
			return result;
	    }
	    
	    /**
	    * Transform radians to degrees
	    * 
	    * @param value	Angle value in radians
	    */
	    static public function degrees( radians: Number ): Number
	    {
	    	return radians * ( 180 / Math.PI );
	    }
	    
	    static public function radians( degree: Number ): Number
	    {
	    	return degree * ( Math.PI / 180 );
	    }

	}//end Point2D

}