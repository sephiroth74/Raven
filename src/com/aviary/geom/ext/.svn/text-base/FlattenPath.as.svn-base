///////////////////////////////////////////////////////////
//  FlattenPath.as
//  Macromedia ActionScript Implementation of the Class FlattenPath
//  Generated by Enterprise Architect
//  Created on:      01-Apr-2008 8:09:22 AM
//  Original author: alessandro crugnola
///////////////////////////////////////////////////////////

package com.aviary.geom.ext
{
	import __AS3__.vec.Vector;
	
	import com.aviary.geom.ext.curves.CubicCurve;
	import com.aviary.geom.path.Curve3Segment;
	import com.aviary.geom.path.CurveSegment;
	import com.aviary.geom.path.IPath;
	import com.aviary.geom.path.ISegment;
	import com.aviary.geom.path.LineSegment;
	
	import flash.geom.Point;
	
	public class FlattenPath
	{
		public static const DEFAULT_FLATNESS: Number = 0.01;
		public static const MIN_CHORD_LENGTH_SQ: Number = 65536 * 65536 / 4;
		public static const MAX_CHORD_LENGTH_SQ: Number = 16 * 16 * 65536 * 65536;
		
		private var _path: IPath;
		private var _flatness: Number;
		private var _points: Vector.<Point>;
		private var _flatness_sq: Number;
		private var _cubic: CubicCurve;
		private var _revorder_segments: Vector.<ISegment>;
		
		public function FlattenPath( path: IPath, flatness: Number = FlattenPath.DEFAULT_FLATNESS )
		{
			const n: uint = path.length;
			
			_revorder_segments = new Vector.<ISegment>( n, false );
			_flatness = flatness;
			
			_points = new Vector.<Point>( );
			_flatness_sq = ( flatness * flatness );
			_cubic = new CubicCurve( 0, 0, 0, 0, 0, 0, 0, 0 );
			
			// fill segments (reverse order). We don't keep a reference of path so the cache can be updated correctly if
			// the path instance is removed from the memory
			for( var i: uint = 0; i < n; ++i )
			{
				_revorder_segments[ int( n - ( i + 1 ) ) ] = path.getSegmentAt( i );
			}
		}
		
		public function get flatness(): Number
		{
			return _flatness;
		}
		
		public function get points(): Vector.<Point>
		{
			if( !isDone() )
			{
				cacheAllPoints();
			}
			
			return _points.concat( );
		}
		
		protected function isDone(): Boolean
		{
			return ( _revorder_segments.length == 0 );
		}
		
		private function cacheAllPoints(): void
		{
			var segment: ISegment;
			
			while( _revorder_segments.length > 0 )
			{
				cacheSegmentPoints( _revorder_segments.pop() );
			}
		}
		
		private function cacheSegmentPoints( segment: ISegment ): void
		{
			switch( true )
			{
				/*case ( segment is MoveSegment ):
					_points.push( null );
				*/
				case ( segment is LineSegment ):
					_points.push( segment.controlHandle.point );
					
					break;
				
				case ( segment is CurveSegment ):
					var quadratic: CurveSegment = ( segment as CurveSegment );
					flattenQuadratic( quadratic );
					
					break;
				
				case ( segment is Curve3Segment ):
					if( segment.prev )
					{
						var cubic: Curve3Segment = ( segment as Curve3Segment );
						flattenCubic( cubic );
					}
					break;
			}
		}
		
		private function flattenQuadratic( quadratic: CurveSegment ): void
		{
			const q0: Point = quadratic.start;
			const q1: Point = quadratic.controlHandle.point;
			const q2: Point = quadratic.end;
			
			const x0: Number = q0.x;
			const x1: Number = 1 / 3 * q0.x + 2 / 3 * q1.x;
			const x2: Number = 2 / 3 * q1.x + 1 / 3 * q2.x;
			const x3: Number = q2.x;
			
			const y0: Number = q0.y;
			const y1: Number = 1 / 3 * q0.y + 2 / 3 * q1.y;
			const y2: Number = 2 / 3 * q1.y + 1 / 3 * q2.y;
			const y3: Number = q2.y;
			
			flattenCubicPoints( x0, y0, x1, y1, x2, y2, x3, y3 );
		}
		
		private function flattenCubic( cubic: Curve3Segment ): void
		{
			const q0: Point = cubic.start;
			const q1: Point = cubic.curveHandle1.point;
			const q2: Point = cubic.curveHandle2.point;
			const q3: Point = cubic.end;
			
			flattenCubicPoints( q0.x, q0.y, q1.x, q1.y, q2.x, q2.y, q3.x, q3.y );
		}
		
		private function flattenCubicPoints( x0: Number, y0: Number, x1: Number, y1: Number, x2: Number, y2: Number, x3: Number, y3: Number ): void
		{
			_cubic.update( x0, y0, x1, y1, x2, y2, x3, y3 );
			
			if( _cubic.getSquareFlatness() > _flatness )
			{
				var halves: Vector.<Number> = _cubic.subdivide();
				
				flattenCubicPoints( halves[ 0 ], halves[ 1 ], halves[ 2 ], halves[ 3 ], halves[ 4 ], halves[ 5 ], halves[ 6 ], halves[ 7 ] );
				flattenCubicPoints( halves[ 8 ], halves[ 9 ], halves[ 10 ], halves[ 11 ], halves[ 12 ], halves[ 13 ], halves[ 14 ], halves[ 15 ] );
			}else
			{
				_points.push( _cubic.a );
				_points.push( _cubic.b );
			}
		}
	}
}