///////////////////////////////////////////////////////////
//  PathSegment.as
//  Macromedia ActionScript Implementation of the Class PathSegment
//  Generated by Enterprise Architect
//  Created on:      01-Apr-2008 8:09:27 AM
//  Original author: alessandro crugnola
///////////////////////////////////////////////////////////

package com.aviary.geom.path
{
	import __AS3__.vec.Vector;
	
	import com.aviary.events.HandleEvent;
	import com.aviary.events.SegmentEvent;
	import com.aviary.geom.controls.IHandle;
	import com.aviary.geom.controls.SegmentHandle;
	import com.aviary.raven.utils.ICloneable;
	
	import flash.events.EventDispatcher;
	import flash.geom.Point;
	import flash.utils.ByteArray;
	import flash.utils.getQualifiedClassName;
	
	import it.sephiroth.gettext._;
	
	import mx.utils.UIDUtil;

	[Event(name="segmentChange", type="com.aviary.events.SegmentEvent")]

	/**
	 * project: GeometrySDK Generalize class for a ISegment
	 * @author alessandro crugnola
	 * @version 1.0
	 * @created 01-Apr-2008 8:09:27 AM
	 */
	public class PathSegment extends EventDispatcher implements ISegment
	{
	    protected var _prev: ISegment;
	    protected var _next: ISegment;
	    protected var _controlPoint: Point;
	    protected var _handles: Vector.<IHandle>;
	    protected var _handles_dict: Object;
	    protected var _uid: String;
	    protected var _commands: Vector.<int>;
	    protected var _data: Vector.<Number>;
	    protected var _path_index: PathIndex;

	    private var _controlHandle: IHandle;
	    
	    /**
	     * 
	     * @param x
	     * @param y    y
	     */
	    public function PathSegment( x: Number, y: Number )
	    {
			super( );
			_path_index = new PathIndex( 0, 0 );
			_uid = UIDUtil.createUID( );
			_controlHandle = new SegmentHandle( 'control', x, y, this );
			_controlPoint  = controlHandle.point;
			_controlHandle.addEventListener( HandleEvent.HANDLE_UPDATE, onHandleUpdate );
			_controlHandle.addEventListener( HandleEvent.HANDLE_CHANGE, onHandleChange );
			_handles = Vector.<IHandle>( [ _controlHandle ] );
			_handles_dict = new Object( );
	    }
	    
	    public function get path_index( ): PathIndex
	    {
	    	return _path_index;
	    }
	    
	    public function get uid( ): String
	    {
	    	return _uid;
	    }
	    
	    public function set uid( value: String): void
	    {
	    	_uid = value;
	    }
	    
	    public function get commands( ): Vector.<int>
	    {
	    	return _commands;
	    }
	    
	    public function get data( ): Vector.<Number>
	    {
	    	return _data;
	    }
	    
	    public function getHandleByUid( value: String ): IHandle
	    {
	    	return _handles[ _handles_dict[ value ] ];
	    }
	    	    
	    
		/**
		 * Find the point at the given position between start and end point
		 * of the current segment
		 * 
		 * @param t Number between 0.0 and 1.0
		 */
		virtual public function getLerp( t: Number ): Point
		{
			throw new Error('NonImplementationException');
		}
		
		virtual protected function onHandleUpdate( event: HandleEvent ): void
		{
		}
		
		virtual protected function onHandleChange( event: HandleEvent ): void
		{
			dispatchEvent( new SegmentEvent( SegmentEvent.SEGMENT_CHANGE ) );
		}
		
		public function invalidate( ): void
		{
		}
		
		/*
		public function get boundingBox( ): Rectangle
		{
			return _boundingBox;
		}
		*/
		
		public function get controlHandle( ): IHandle
		{
			return _controlHandle;
		}
		
		public function get start( ):Point
		{
			return _prev.end;
		}
		
		public function get end( ):Point
		{
			return _controlPoint;
		}
		
		public function get length( ):Number
		{
			return Point.distance( _prev.end, _controlPoint );
		}
		
		public function get prev( ): ISegment
		{
			return _prev;
		}
		
		public function set prev( value: ISegment ): void
		{
			if( value != this )
				_prev = value;
		}
		
		public function get next( ): ISegment
		{
			return _next;
		}
		
		public function set next( value: ISegment ): void
		{
			if( value != this )
				_next = value;
		}
		
		public function get isEndSegment( ): Boolean
		{
			return ( next == null || prev == null /*|| next is MoveSegment || this is MoveSegment*/ );
		}
		
		public function get handles( ): Vector.<IHandle>
		{
			return _handles;
		}
		
		public function encode( byte: ByteArray ): void
		{
			throw new Error("NonImplementationException");
		}
		
		public static function decode( label: String, item: Object ): ISegment
		{
			var segment: ISegment;
			
			switch( label )
			{
				case getQualifiedClassName( LineSegment ):
				case "com.aviary.geom::LineSegment":
					segment = new LineSegment( item.x, item.y );
					break;
				
				case getQualifiedClassName( MoveSegment ):
				case "com.aviary.geom::MoveSegment":
					segment = new MoveSegment( item.x, item.y );
					break;
					
				case getQualifiedClassName( Curve3Segment ):
				case "com.aviary.geom::Curve3Segment":
					segment = new Curve3Segment( item.cx1, item.cy1, item.cx2, item.cy2, item.x, item.y );
					break;
					
				default:
					throw new Error( label + _(" is not implemented"));
			}
			
			segment.uid = item.uid;
			return segment;
		}
		
		virtual public function getClosestPoint( p: Point ): Point
		{
			throw new Error("NonImplementationException");
		}
		
		virtual public function getSegmentLength( p: Point ): Number
		{
			throw new Error("NonImplementationException");
		}
		
		virtual public function clone( ): ICloneable
		{
			throw new Error("NonImplementationException");
		}

	}//end PathSegment

}