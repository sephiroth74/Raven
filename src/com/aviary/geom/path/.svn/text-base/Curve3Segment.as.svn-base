///////////////////////////////////////////////////////////
//  Curve3Segment.as
//  Macromedia ActionScript Implementation of the Class Curve3Segment
//  Generated by Enterprise Architect
//  Created on:      01-Apr-2008 8:09:21 AM
//  Original author: alessandro crugnola
///////////////////////////////////////////////////////////

package com.aviary.geom.path
{
	import __AS3__.vec.Vector;
	
	import com.aviary.events.HandleEvent;
	import com.aviary.events.SegmentEvent;
	import com.aviary.geom.controls.HandleType;
	import com.aviary.geom.controls.IHandle;
	import com.aviary.geom.controls.SegmentHandle;
	import com.aviary.geom.utils.Point2D;
	import com.aviary.raven.utils.ICloneable;
	
	import flash.display.GraphicsPathCommand;
	import flash.geom.Point;
	import flash.utils.ByteArray;
	import flash.utils.Dictionary;

	/**
	 * @author alessandro crugnola
	 * @version 1.0
	 * @created 01-Apr-2008 8:09:21 AM
	 */
	public class Curve3Segment extends PathSegment implements ICurveSegment
	{
		static private const MAXDEPTH: int		= 64;    // Maximum depth for recursion
		static private const EPSILON: Number 	= Math.pow( 2, - MAXDEPTH - 1 ); // Flatness control value
		
		/* Precomputed "z" for cubics   */
	    private static const CUBICZ: Array = [  
	        [ 1.0, 0.6, 0.3, 0.1 ],
	        [ 0.4, 0.6, 0.6, 0.4 ],
	        [ 0.1, 0.3, 0.6, 1.0 ],
    	];
		
	    private var _curveHandle1: SegmentHandle;
	    private var _curveHandle2: SegmentHandle;
	    private var c1: Point;
	    private var c2: Point;
	    private var pre_pt: Dictionary;
	    private var pre_seg: Dictionary;
	    private var dirty: Boolean;
	    private var ax: Number;
	    private var bx: Number;
	    private var gx: Number;
	    private var ay: Number;
	    private var by: Number;
	    private var gy: Number;

	    /**
	     * 
	     * @param cx1
	     * @param cy1
	     * @param cx2
	     * @param cy2
	     * @param x
	     * @param y    y
	     */
	    public function Curve3Segment( cx1: Number, cy1: Number, cx2: Number, cy2: Number, x: Number, y: Number )
	    {
			super( x, y );
			_curveHandle1 = new SegmentHandle('curve1', cx1, cy1, this, HandleType.CONTROL_FORM );
			_curveHandle2 = new SegmentHandle('curve2', cx2, cy2, this, HandleType.CONTROL_FORM );
			_curveHandle2.parentHandle = controlHandle;
			c1 = _curveHandle1.point;
			c2 = _curveHandle2.point;
			
			pre_pt  = new Dictionary();
			pre_seg = new Dictionary();			
			
			_handles = Vector.<IHandle>( [ _curveHandle1, _curveHandle2, controlHandle ] );
			
			_handles_dict[ _curveHandle1.name ] = 0;
			_handles_dict[ _curveHandle2.name ] = 1;
			_handles_dict[ controlHandle.name ] = 2;
			
			controlHandle.addEventListener( HandleEvent.HANDLE_UPDATE, onHandleUpdate );
			_curveHandle1.addEventListener( HandleEvent.HANDLE_UPDATE, onHandleUpdate );
			_curveHandle2.addEventListener( HandleEvent.HANDLE_UPDATE, onHandleUpdate );
			
			dirty = true;
			
			_commands = new Vector.<int>( 4, true );
			_commands[0] = GraphicsPathCommand.CURVE_TO;
			_commands[1] = GraphicsPathCommand.CURVE_TO;
			_commands[2] = GraphicsPathCommand.CURVE_TO;
			_commands[3] = GraphicsPathCommand.CURVE_TO;
			
			_data = new Vector.<Number>( 16, true );
			updateFactors( );
			updateData( );
	    }
	    
	    /*
		override public function get handles( ): Vector.<IHandle>
		{
			return ( prev ? Vector.<IHandle>( [ _curveHandle1, _curveHandle2, controlHandle ] ) : Vector.<IHandle>( [ controlHandle ] ) );
		}
		*/    

	    public function get curveHandle1(): IHandle
	    {
			return _curveHandle1;
	    }

	    public function get curveHandle2(): IHandle
	    {
			return _curveHandle2;
	    }

	    /**
	     * 
	     * @param event    event
	     */
	    protected override function onHandleUpdate(event:HandleEvent): void
	    {
			super.onHandleUpdate( event );
			updateFactors( );
			updateData( );
			dispatchEvent( new SegmentEvent( SegmentEvent.SEGMENT_CHANGE ) );
	    }

	    private function updateData( ): void
	    {
	    	if( dirty )
	    	{
	    		if( prev )
	    		{
					var PA: Point 	 = Point2D.getLerp( start, c1, 3/4 );
					var PB: Point 	 = Point2D.getLerp( _controlPoint, c2, 3/4 );
					var dv: Point 	 = Point2D.divideEquals( _controlPoint.subtract( start ), 16 );
					var Pc_1: Point  = Point2D.getLerp( start, c1, 3/8 );
					var Pc_2: Point  = Point2D.subtractPointEquals( Point2D.getLerp( PA, PB, 3/8 ), dv);
					var Pc_3: Point  = Point2D.addPointEquals( Point2D.getLerp( PB, PA, 3/8), dv);
					var Pc_4: Point  = Point2D.getLerp( _controlPoint, c2, 3/8 );
					var Pa_1: Point  = Point2D.getLerp( Pc_1, Pc_2, 0.5 );
					var Pa_2: Point  = Point2D.getLerp( PA, PB, 0.5 );
					var Pa_3: Point  = Point2D.getLerp( Pc_3, Pc_4, 0.5 );
		
					_data[0] = Pc_1.x;
					_data[1] = Pc_1.y;
					_data[2] = Pa_1.x;
					_data[3] = Pa_1.y;
					_data[4] = Pc_2.x;
					_data[5] = Pc_2.y;
					_data[6] = Pa_2.x;
					_data[7] = Pa_2.y;
					_data[8] = Pc_3.x;
					_data[9] = Pc_3.y;
					_data[10] = Pa_3.x;
					_data[11] = Pa_3.y;
					_data[12] = Pc_4.x;
					_data[13] = Pc_4.y;
					_data[14] = _controlPoint.x;
					_data[15] = _controlPoint.y;
	    			dirty = false;
	    		} else 
	    		{
					for( var a: int = 0; a < _data.length - 1; a += 2 )
					{
						_data[a] = end.x;
						_data[a+1] = end.y;
					}	
	    		}
	    	}
	    }

	    /**
	     * 
	     * @param t    t
	     */
	    public override function getLerp(t:Number): Point
	    {
			if ( pre_pt[t] == null ) 
			{
				var ts:Number = t*t;
				pre_pt[t] = new Point( ax*ts*t + bx*ts + gx*t + start.x , ay*ts*t + by*ts + gy*t + start.y );
			}
			return pre_pt[t];
	    }

	    public function updateFactors( ): void
	    {
			if( !prev ) return;
			gx = 3 * ( c1.x - start.x );
			bx = ( 3 * ( c2.x - c1.x) ) - gx;
			ax = _controlPoint.x - start.x - bx - gx;
			gy = 3 * ( c1.y - start.y );
			by = ( 3 * ( c2.y - c1.y ) ) - gy;
			ay = _controlPoint.y - start.y - by - gy;
			dirty = true;
	    }

	    /**
	     * 
	     * @param value    value
	     */
	    public override function set prev( value: ISegment ): void
	    {
			if( prev )
			{
				prev.removeEventListener( HandleEvent.HANDLE_UPDATE, onHandleUpdate );
				_curveHandle1.parentHandle = null;
			}
			
			if( value )
			{
				value.addEventListener( HandleEvent.HANDLE_UPDATE, onHandleUpdate );
				_curveHandle1.parentHandle = value.controlHandle;
				_handles = Vector.<IHandle>( [ _curveHandle1, _curveHandle2, controlHandle ] );
			} else 
			{
				_curveHandle1.parentHandle = null;
				_handles = Vector.<IHandle>( [ controlHandle ] );
			}
			
			super.prev = value;
			
			updateFactors( );
			updateData( );
	    }

	    /**
	     * 
	     * @param value    value
	     */
	    public override function set next(value:ISegment): void
	    {
			super.next = value;
			updateFactors( );
			updateData( );
	    }

	    public override function encode( byte: ByteArray ): void
	    {
	    	var obj: Object = { 
	    				cx1 : _curveHandle1.point.x,
	    				cy1 : _curveHandle1.point.y,
	    				cx2 : _curveHandle2.point.x,
	    				cy2 : _curveHandle2.point.y,
	    				x: controlHandle.point.x, 
	    				y: controlHandle.point.y, 
	    				prev: prev ? prev.uid : "",
	    				next: next ? next.uid : "",
	    				uid: uid
	    				};
	    				
	    	byte.writeObject( obj );
	    }	    
	    
	    override public function getClosestPoint( p: Point ): Point
	    {
			var tCandidate:Array = [];     // Possible roots
			var w:Array = convertToBezierForm( p );
			var nSolutions:int = findRoots( w, tCandidate, 0 );
			
			// Compare distances of P5 to all candidates, and to t=0, and t=1
			// Check distance to beginning of curve, where t = 0
			var minDistance: Number = Point.distance( p, start );
			var pp: Point;
				var bestP: Point = start;
			
			// Find distances for candidate points
			var distance: Number;
			for (var i: int = 0; i < nSolutions; i++ ) 
			{
				pp = getLerp( tCandidate[i] );
			    distance = Point.distance( p, pp );
			    if ( distance < minDistance ) 
			    {
			        minDistance = distance;
			        bestP = pp;
			    }
			}
			
			// Finally, look at distance to end point, where t = 1.0
			distance =  Point.distance( pp, _controlPoint );
			if ( distance < minDistance ) 
			{
			    minDistance = distance;
			    bestP = _controlPoint;
			}
			return bestP;
	    }
	    
		override public function getSegmentLength( p: Point ): Number
	    {
			var tCandidate:Array = [];
	        var w:Array = convertToBezierForm( p );
	        var nSolutions:int = findRoots( w, tCandidate, 0 );
	        var minDistance: Number = Point.distance( p, start );
	        var pp: Point;
			var bestP: Number = 0;
			
	        var distance: Number;
	        for (var i: int = 0; i < nSolutions; i++ ) 
	        {
	        	pp = getLerp( tCandidate[i] );
	            distance = Point.distance( p, pp );
	            if ( distance < minDistance ) 
	            {
	                minDistance = distance;
	                bestP = tCandidate[i];
	            }
	        }
	
	        // Finally, look at distance to end point, where t = 1.0
	        distance =  Point.distance( pp, _controlPoint );
	        if ( distance < minDistance ) 
	        {
	            minDistance = distance;
	            bestP = 1;
	        }
			return bestP;
	    }
	    
		/**
	     * CrossingCount :
	     * Count the number of times a Bezier control polygon 
	     * crosses the 0-axis. This number is >= the number of roots.
	     * 
	     */
	     private function crossingCount( v: Array,  degree: int ): int 
	     {
	        var nCrossings: int = 0;
	        var sign: int = Point( v[0] ).y < 0 ? -1 : 1;
	        var oldSign: int = sign;
	        for (var i: int = 1; i <= degree; i++ ) 
	        {
	            sign = Point( v[i] ).y < 0 ? -1 : 1;
	            if ( sign != oldSign ) nCrossings++;
	            oldSign = sign;
	        }
	        return nCrossings;
	    }
	    
	    /**
	     * ComputeXIntercept :
	     * Compute intersection of chord from first control point to last with 0-axis.
	     * 
	     */
	    private function computeXIntercept( v: Array,  degree: int ): Number
		{
	        var XNM: Number = Point( v[degree] ).x - v[0].x;
	        var YNM: Number = Point( v[degree] ).y - v[0].y;
	        var XMK: Number = Point( v[0] ).x;
	        var YMK: Number = Point( v[0] ).y;
	        var detInv: Number = - 1.0 / YNM;
	        return ( XNM * YMK - YNM * XMK ) * detInv;
	    }	    
	    
    	 /**
    	  * ControlPolygonFlatEnough
	      * Check if the control polygon of a Bezier curve is flat enough
	      * for recursive subdivision to bottom out.
	      *
	      */
	     private function controlPolygonFlatEnough( v: Array, degree: int ): Boolean
	     {
	        // Find the  perpendicular distance
	        // from each interior control point to
	        // line connecting v[0] and v[degree]
	    
	        // Derive the implicit equation for line connecting first
	        // and last control points
	        var a:Number = v[0].y - v[degree].y;
	        var b:Number = v[degree].x - v[0].x;
	        var c:Number = v[0].x * v[degree].y - v[degree].x * v[0].y;
	    
	        var abSquared:Number = ( a * a ) + ( b * b );
	        var distance:Array =[];      // Distances from pts to line
    
	        for ( var i: int = 1; i < degree; i++ )
	        {
	        	// Compute distance from each of the points to that line
	            distance[i] = a * v[i].x + b * v[i].y + c;
	            if ( distance[i] > 0.0 )
	            {
	                distance[i] = ( distance[i] * distance[i] ) / abSquared;
	            }
	            if (distance[i] < 0.0)
	            {
	                distance[i] = -( ( distance[i] * distance[i] ) / abSquared );
	            }
	        }

	        // Find the largest distance
	        var maxDistanceAbove:Number = 0.0;
	        var maxDistanceBelow:Number = 0.0;
	       
            for ( i = 1; i < degree; i++ ) 
            {
	            if ( distance[i] < 0.0 )
	            {
	                maxDistanceBelow = Math.min( maxDistanceBelow, distance[i] );
	            }
	            if ( distance[i] > 0.0 )
	            {
	                maxDistanceAbove = Math.max( maxDistanceAbove, distance[i] );
	            }
	        }
	    
	        // Implicit equation for zero line
	        var a1: Number = 0.0;
	        var b1: Number = 1.0;
	        var c1: Number = 0.0;
	    
	        // Implicit equation for "above" line
	        var a2: Number = a;
	        var b2: Number = b;
	        var c2: Number = c + maxDistanceAbove;
	    
	        var det:  Number = a1 * b2 - a2 * b1;
	        var dInv: Number = 1.0 / det;
	        
	        var intercept1:Number = ( b1 * c2 - b2 * c1 ) * dInv;
	    
	        //  Implicit equation for "below" line
	        a2 = a;
	        b2 = b;
	        c2 = c + maxDistanceBelow;
	        
	        det = a1 * b2 - a2 * b1;
	        dInv = 1.0/det;
	        
	        var intercept2:Number = ( b1 * c2 - b2 * c1 ) * dInv;
	    
	        // Compute intercepts of bounding box
	        var leftIntercept: Number = Math.min( intercept1, intercept2 );
	        var rightIntercept: Number = Math.max( intercept1, intercept2 );
	    
	        var error:Number = 0.5 * ( rightIntercept - leftIntercept );    
	        
	        return error < EPSILON;
	    }	    
	    
	    private function findRoots( w: Array, t: Array,  depth: int ): int 
	    {  
	        switch ( crossingCount( w, 5 ) ) 
	        {
	            case 0 : { // No solutions here
	                return 0;   
	            }
	            case 1 : { // Unique solution
	            
	                // Stop recursion when the tree is deep enough
	                // if deep enough, return 1 solution at midpoint
	                if ( depth >= MAXDEPTH )
	                {
	                    t[0] = ( Point( w[0] ).x + Point( w[5]).x ) / 2.0;
	                    return 1;
	                }
	                if ( controlPolygonFlatEnough( w, 5 ) ) 
	                {
	                    t[0] = computeXIntercept( w, 5 );
	                    return 1;
	                }
	                break;
	            }
	        }
	
	        // Otherwise, solve recursively after
	        // subdividing control polygon
	        var left:Array = [];    // New left and right
	        var right:Array = [];   // control polygons
	        var leftT:Array =  [];            // Solutions from kids
	        var rightT:Array =  [];
	        
	        var p:Array = [[],[],[],[],[],[]];
        	var i:int, j:int;
         	for ( j=0; j <= 5; j++) 
         	{
           	 	p[0][j] = new Point( Point( w[j] ).x, Point( w[j] ).y );
        	}
	       
            /* Triangle computation */
	        for ( i = 1; i <= 5; i++ )
	        {  
	            for ( j = 0 ; j <= 5 - i; j++ ) 
	            {
	                p[i][j] = new Point(
	                    0.5 * p[i-1][j].x + 0.5 * p[i-1][j+1].x,
	                    0.5 * p[i-1][j].y + 0.5 * p[i-1][j+1].y
	                );
	            }
	        }
        
	        if ( left != null )
	        {
	            for ( j = 0; j <= 5; j++ )
	            {
					left[j]  = p[j][0];
	            }
	        }
        
	        if ( right != null )
	        {
	            for ( j = 0; j <= 5; j++ )
	            {
	                right[j] = p[5-j][j];
	            }
	        }
        
        	var leftCount: int  = findRoots( left,  leftT, depth + 1 );
	        var rightCount: int = findRoots( right, rightT, depth + 1 );
	    
	        // Gather solutions together
	        for ( i = 0; i < leftCount; i++ ) 
	        {
	            t[i] = leftT[i];
	        }
	        for ( i = 0; i < rightCount; i++ ) 
	        {
	            t[i+leftCount] = rightT[i];
	        }
	    
	        // Send back total number of solutions  */
	        return leftCount + rightCount;
	    }	    
	    
	    private function convertToBezierForm( pa: Point ): Array 
	    {
			var lb: int, ub: int, i: int, j: int, k: int
			var v: Point;
	        var c: Array = [];   // v(i) - pa
	        var d: Array = [];    // v(i+1) - v(i)
	        var cdTable: Array = [[],[],[]]  // Dot product of c, d
	        var w: Array = []; // Ctl pts of 5th-degree curve
	
	        // Determine the c's -- these are vectors created by subtracting
	        // point pa from each of the control points
	        c.push( Point2D.sub( start, pa ) );
	        c.push( Point2D.sub( c1, pa ) );
	        c.push( Point2D.sub( c2, pa ) );
	        c.push( Point2D.sub( end, pa ) );
	        
	        // Determine the d's -- these are vectors created by subtracting
	        // each control point from the next
	        var s: Number = 3;
	        
	        d.push( Point2D.addLengthEquals( Point2D.sub( c1, start ), s ) );
	        d.push( Point2D.addLengthEquals( Point2D.sub( c2, c1 ), s ) );
	        d.push( Point2D.addLengthEquals( Point2D.sub( end, c2 ), s ) );
	        
	        
	        // Create the c,d table 
	        // this is a table of dot products of the
	        // c's and d's
	        for ( var row: int = 0; row <= 2; row++ ) 
	        {
	            for ( var column: int = 0; column <= 3; column++ ) 
	            {
	                cdTable[row][column] = Point2D.dot( Point( d[row] ), Point( c[column] ) );
	            }
	        }
	
	        // Now, apply the z's to the dot products, on the skew diagonal
	        // Also, set up the x-values, making these "points"
	        for ( i = 0; i <= 5; i++) 
	        {
	            w[i] = new Point( Number( i ) / 5, 0 );
	        }
			
	        var n: int = 3;
	        var m: int = 2;
	        for ( k = 0; k <= n + m; k++ ) 
	        {
	            lb = Math.max( 0, k - m );
	            ub = Math.min( k, n );
	            for ( i = lb; i <= ub; i++ ) 
	            {
	                j = k - i;
	                Point( w[i+j] ).y += cdTable[j][i] * CUBICZ[j][i];
	            }
	        }
	
	        return w;
	    }	    

		override public function get length( ):Number
		{
			throw new Error("NonImplementationException");
		}
		
		override public function clone(): ICloneable
		{
			return new Curve3Segment( c1.x, c1.y, c2.x, c2.y, this.end.x, this.end.y );
		}
		
		override public function toString( ): String
		{
			return "curve3(" + c1.x + "," + c1.y + "," + c2.x + "," + c2.y + "," + this.end.x + "," + this.end.y + ")";
		}
		
		public static function subdivide( p0: Point, p1: Point, p2: Point, p3: Point, t: Number = 0.5 ): Array
		{
			var t2: Number = 1 - t;
			var r: Point  = Point2D.multiply( p1, t2 ).add( Point2D.multiply( p2, t ) );
			var q1: Point = Point2D.multiply( p0, t2 ).add( Point2D.multiply( p1, t ) );
			var q2: Point = Point2D.multiply( q1, t2 ).add( Point2D.multiply( r, t ) );
			var q5: Point = Point2D.multiply( p2, t2 ).add( Point2D.multiply( p3, t ) );
			var q4: Point = Point2D.multiply( r, t2 ).add( Point2D.multiply( q5, t ) );
			var q3: Point = Point2D.multiply( q2, t2 ).add( Point2D.multiply( q4, t ) );
			return [ q1, q2, q3, q4, q5 ];
		}
		
		
	}//end Curve3Segment
}
