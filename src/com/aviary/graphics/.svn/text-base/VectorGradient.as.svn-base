///////////////////////////////////////////////////////////
//  VectorGradient.as
//  Macromedia ActionScript Implementation of the Class VectorGradient
//  Generated by Enterprise Architect
//  Created on:      01-Apr-2008 8:09:32 AM
//  Original author: alessandro crugnola
///////////////////////////////////////////////////////////

package com.aviary.graphics
{
	import com.aviary.raven.utils.ICloneable;
	
	import flash.display.GradientType;
	import flash.display.Graphics;
	import flash.events.EventDispatcher;
	import flash.geom.Matrix;
	import flash.geom.Rectangle;
	import flash.utils.ByteArray;
	
	import mx.graphics.GradientEntry;
	
	/**
	 * @author alessandro crugnola
	 * @version 1.0
	 * @created 01-Apr-2008 8:09:32 AM
	 */
	public class VectorGradient extends EventDispatcher implements IVectorFill
	{
	    static public const RATIO_CONVERT: Number = 255;
	    
	    protected var m_entries: Array = [];
	    protected var m_gstops: Object;
	    protected var m_matrix: Matrix = new Matrix();
	
	    public function VectorGradient()
	    {
	    	super();
	    }
	
	    public function get gstops(): Object
	    {
	    	return m_gstops;
	    }
	
	    /**
	     * 
	     * @param value    value
	     */
	    public function set entries(value:Array): void
	    {
			//if( value )
			//	( value[ value.length - 1 ] as GradientEntry ).ratio = 1;
				
			m_entries = value;
			m_gstops  = null;
			updateGStops( );	    	
	    }
	
	    [Bindable]
	    public function get entries(): Array
	    {
	    	return m_entries.concat( );
	    }
	
	    /**
	     * 
	     * @param value
	     * @param pos    pos
	     */
	    public function setEntryAt(value:GradientEntry, pos:uint): void
	    {
			if( m_entries && ( pos < m_entries.length ) )
			{
				m_entries[ pos ] = value;
				if( m_gstops )
				{
					m_gstops.colors[ pos ] = value.color;
					m_gstops.ratios[ pos ] = value.ratio * RATIO_CONVERT;
					m_gstops.alphas[ pos ] = value.alpha;
				} else {
					updateGStops( );
				}
			}
	    }
	
	    /**
	     * 
	     * @param pos    pos
	     */
	    public function getEntryAt(pos:uint): GradientEntry
	    {
	    	return m_entries[ pos ];
	    }
	
	    private function updateGStops(): void
	    {
			if ( !m_entries )
				return;
	
			var colors:Array = [];
			var ratios:Array = [];
			var alphas:Array = [];
			var i:int;
			var n:int = m_entries.length;
			for ( i = 0; i < n; i++ )
			{
				var e:GradientEntry = m_entries[ i ];
				colors.push( e.color );
				alphas.push( e.alpha );
				ratios.push( e.ratio * RATIO_CONVERT );
			}
			
			if ( isNaN( ratios[0] ) )
				ratios[0] = 0;
				
			if ( isNaN( ratios[n - 1] ) )
				ratios[n - 1] = 255;

			m_gstops = { colors: colors, ratios: ratios, alphas: alphas };	    	
	    }
	
	    /**
	     * 
	     * @param target
	     * @param rc
	     * @param rotation
	     * @param spread
	     * @param interpolation
	     * @param focal    focal
	     */
	    protected function beginLinearFill(target:Graphics, rc:Rectangle, rotation:Number, spread:String, interpolation:String, focal:Number): void
	    {
			m_matrix.createGradientBox( rc.width, rc.height, rotation, rc.left, rc.top );
			target.beginGradientFill( GradientType.LINEAR, m_gstops.colors, m_gstops.alphas, m_gstops.ratios, m_matrix, spread, interpolation, focal );		
	    	
	    }
	
	    /**
	     * 
	     * @param target
	     * @param rc
	     * @param rotation
	     * @param spread
	     * @param interpolation
	     * @param focal    focal
	     */
	    protected function beginGradientFill(target:Graphics, rc:Rectangle, rotation:Number, spread:String, interpolation:String, focal:Number): void
	    {
			m_matrix.createGradientBox( rc.width * 2, rc.height, 0, rc.left, rc.top );
			m_matrix.tx = -( rc.width / 2 );
			m_matrix.ty = -( rc.height / 2 );
			m_matrix.rotate( rotation );
			m_matrix.tx = rc.x + ( rc.width / 2 );
			m_matrix.ty = rc.y + ( rc.height / 2 );
				
			target.beginGradientFill( GradientType.RADIAL,
									 m_gstops.colors, m_gstops.alphas,
									 m_gstops.ratios, m_matrix,
									 spread, interpolation, focal );
	    	
	    }
	
	    /**
	     * 
	     * @param target    target
	     */
	    protected function beginSolidFill(target:Graphics): void
	    {
	    	target.beginFill( getEntryAt( 0 ).color, getEntryAt( 0 ).alpha );
	    }
	
	    /**
	     * IRavenFill
	     */
	    public function clone(): ICloneable
	    {
			var byte: ByteArray = new ByteArray( );
			byte.writeObject( this );
			byte.position = 0;
			
			var loaded: Object = byte.readObject( );
			
			var result: ICloneable = new VectorGradient( );
			var new_entries: Array = new Array( );
			var new_gradient: GradientEntry;
			
			for each( var loaded_gradient: Object in loaded.entries )
			{
				new_gradient = new GradientEntry( loaded_gradient.color, loaded_gradient.ratio, loaded_gradient.alpha );
				new_entries.push( new_gradient );
			}
			( result as VectorGradient ).entries = new_entries;
			return result;	    	
	    }
	
	    /**
	     * 
	     * @param target
	     * @param rc
	     * @param type    FillType
	     * @param angle
	     * @param spread
	     * @param interpolation
	     * @param focalpoint    focalpoint
	     */
	    public function begin(target:Graphics, rc:Rectangle, type:uint = 1, angle:Number = 0, spread:String = 'pad', interpolation:String = 'rgb', focalpoint:Number = 0): void
	    {
			if( m_gstops == null || rc == null ) return;
			
			if( type == FillType.LINEAR  )
				beginLinearFill( target, rc, angle, spread, interpolation, focalpoint );
			else if( type == FillType.RADIAL )
				beginGradientFill( target, rc, angle, spread, interpolation, focalpoint );
			else
				beginSolidFill( target );
	    }
	
	    /**
	     * 
	     * @param target    target
	     */
	    public function end(target:Graphics): void
	    {
	    	target.endFill( );
	    }
	
	}//end VectorGradient
}