///////////////////////////////////////////////////////////
//  VectorStroke.as
//  Macromedia ActionScript Implementation of the Class VectorStroke
//  Generated by Enterprise Architect
//  Created on:      01-Apr-2008 8:09:32 AM
//  Original author: alessandro crugnola
///////////////////////////////////////////////////////////

package com.aviary.graphics
{
	import com.aviary.raven.utils.ICloneable;
	
	import flash.display.CapsStyle;
	import flash.display.Graphics;
	import flash.display.InterpolationMethod;
	import flash.display.JointStyle;
	import flash.display.LineScaleMode;
	import flash.display.SpreadMethod;
	import flash.events.EventDispatcher;
	import flash.geom.Matrix;
	import flash.geom.Rectangle;
	
	import mx.graphics.GradientEntry;
	
	/**
	 * @author alessandro crugnola
	 * @version 1.0
	 * @created 01-Apr-2008 8:09:32 AM
	 */
	public class VectorStroke extends EventDispatcher implements IVectorStroke
	{
	    static public const RATIO_CONVERT: Number = 255;
	    
	    protected var _entries: Array = [];
	    protected var _gstops: Object;
	    protected var _weight: Number;
	    protected var _pixelHinting: Boolean;
	    protected var _scaleMode: String = LineScaleMode.NONE;
	    protected var _caps: String = CapsStyle.NONE;
	    protected var _joints: String = JointStyle.MITER;
	    protected var _miterLimit: Number = 0;
	    protected var _interpolationMethod: String = InterpolationMethod.RGB;
	    protected var _spreadMethod: String = SpreadMethod.PAD;
	    protected var _type: uint = StrokeType.NONE;
	    protected var _matrix: Matrix = new Matrix( );
	
	    /**
	     * 
	     * @param weight
	     * @param pixelHinting
	     * @param scaleMode
	     * @param caps
	     * @param joints
	     * @param miterLimit    miterLimit
	     */
	    public function VectorStroke(weight:Number = 0, pixelHinting:Boolean = false, scaleMode:String = 'none', caps:String = 'none', joints:String = 'miter', miterLimit:Number = 0)
	    {
			super( );
			this._weight      = weight;
			this.pixelHinting = pixelHinting;
			this.scaleMode  = scaleMode;
			this.caps       = caps;
			this.joints     = joints;
			this.miterLimit = miterLimit;
	    }
	
	    public function clone(): ICloneable
	    {
	    	throw new Error('NonImplementationException');
	    }
	
	    public function get gstops(): Object
	    {
	    	return _gstops;
	    }
	
	    public function get spreadMethod(): String
	    {
	    	return _spreadMethod;
	    }
	
	    /**
	     * 
	     * @param value    value
	     */
	    public function set spreadMethod(value:String): void
	    {
	    	_spreadMethod = value;
	    }
	
	    public function get interpolationMethod(): String
	    {
	    	return _interpolationMethod;
	    }
	
	    /**
	     * 
	     * @param value    value
	     */
	    public function set interpolationMethod(value:String): void
	    {
	    	_interpolationMethod = value;
	    }
	
	    public function get miterLimit(): Number
	    {
	    	return _miterLimit;
	    }
	
	    /**
	     * 
	     * @param value    value
	     */
	    public function set miterLimit(value:Number): void
	    {
	    	_miterLimit = value;
	    }
	
	    public function get joints(): String
	    {
	    	return _joints;
	    }
	
	    /**
	     * 
	     * @param value    value
	     */
	    public function set joints(value:String): void
	    {
	    	_joints = value;
	    }
	
	    public function get caps(): String
	    {
	    	return _caps;
	    }
	
	    /**
	     * 
	     * @param value    value
	     */
	    public function set caps(value:String): void
	    {
	    	_caps = value;
	    }
	
	    public function get scaleMode(): String
	    {
	    	return _scaleMode;
	    }
	
	    /**
	     * 
	     * @param value    value
	     */
	    public function set scaleMode(value:String): void
	    {
	    	_scaleMode = value;
	    }
	
	    public function get pixelHinting(): Boolean
	    {
	    	return _pixelHinting;
	    }
	
	    /**
	     * 
	     * @param value    value
	     */
	    public function set pixelHinting(value:Boolean): void
	    {
	    	_pixelHinting = value;
	    }
	
	    public function get weight(): Number
	    {
	    	return _weight;
	    }
	
	    /**
	     * 
	     * @param value    value
	     */
	    public function set weight( value: Number ): void
	    {
	    	_weight = value;
	    }
	
	    /**
	     * 
	     * @param g
	     * @param type
	     * @param rc    rc
	     */
	    public function apply(g:Graphics, type:uint, rc:Rectangle = null): void
	    {
	    	throw new Error("NonImplementationError");
	    }
	
	    [Bindable]
	    public function get entries(): Array
	    {
	    	return _entries.concat( );
	    }
	
	    /**
	     * 
	     * @param value    value
	     */
	    public function set entries(value:Array): void
	    {
			if( value && value.length > 0 )
				( value[ value.length - 1 ] as GradientEntry ).ratio = 1;
				
			_entries = value;
			_gstops  = null;
			updateGStops( );
	    }
	
	    /**
	     * 
	     * @param value
	     * @param pos    pos
	     */
	    public function setEntryAt(value:GradientEntry, pos:uint): void
	    {
			if( _entries && ( pos < _entries.length ) )
			{
				_entries[ pos ] = value;
				if( _gstops )
				{
					_gstops.colors[ pos ] = value.color;
					_gstops.ratios[ pos ] = value.ratio * RATIO_CONVERT;
					_gstops.alphas[ pos ] = value.alpha;
				} else {
					updateGStops( );
				}
			}
	    }
	
	    /**
	     * 
	     * @param pos    pos
	     */
	    public function getEntryAt(pos:uint): GradientEntry
	    {
	    	return _entries[ pos ];
	    }
	
	    private function updateGStops(): void
	    {
			if ( !_entries )
				return;
	
			var colors:Array = [];
			var ratios:Array = [];
			var alphas:Array = [];
			var i:int;
			var n:int = _entries.length;
			for ( i = 0; i < n; i++ )
			{
				var e:GradientEntry = _entries[ i ];
				colors.push( e.color );
				alphas.push( e.alpha );
				ratios.push( e.ratio * RATIO_CONVERT );
			}
			
			if ( isNaN( ratios[0] ) )
				ratios[0] = 0;
				
			if ( isNaN( ratios[n - 1] ) )
				ratios[n - 1] = 255;

			_gstops = { colors: colors, ratios: ratios, alphas: alphas };	    	
	    }
	
	}//end VectorStroke
}